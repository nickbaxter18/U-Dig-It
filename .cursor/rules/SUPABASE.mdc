---
description: "Supabase backend operations with MCP tools only. Includes database design standards (snake_case, UUIDs, timestamps, foreign keys, indexes), RLS policies with (SELECT auth.uid()) wrapper, query optimization with specific columns and pagination, migration safety patterns, and storage best practices. All patterns include @filename references to actual migrations and queries."
alwaysApply: true
---

# Supabase Backend Excellence

## üéØ Purpose
**HIGHEST PRIORITY**: All database operations use Supabase exclusively via MCP tools.

**IMPORTANT**: For API keys and secrets management, see `api-keys-secrets-management.mdc` - Never access `process.env` directly for secrets!

---

## 1) Supabase Priority Rule

**Note**: This rule is comprehensive (513 lines) to cover all Supabase patterns. While the [Cursor documentation](https://cursor.com/docs/context/rules) recommends rules under 500 lines, this rule is intentionally comprehensive to provide complete database patterns in one place. It's organized into clear sections for easy reference.

### Mandatory Tool Usage
```typescript
// ‚úÖ CORRECT - Always use Supabase MCP tools
await mcp_supabase_execute_sql({ query: 'SELECT ...' });
await mcp_supabase_list_tables({ schemas: ['public'] });
await mcp_supabase_apply_migration({ name: '...', query: '...' });

// ‚ùå FORBIDDEN - Never modify NestJS backend
// The /backend directory is LEGACY and INACTIVE
// Do not reference or modify it
```

### Database Operations
- **Schema verification**: `mcp_supabase_list_tables`
- **Data queries**: `mcp_supabase_execute_sql`
- **Schema changes**: `mcp_supabase_apply_migration`
- **Performance**: `mcp_supabase_get_advisors({ type: 'performance' })`
- **Security**: `mcp_supabase_get_advisors({ type: 'security' })`
- **Debugging**: `mcp_supabase_get_logs({ service: 'api' })`

---

## 2) Database Design Standards

### Naming Conventions (STRICT)
```sql
-- ‚úÖ CORRECT - snake_case for everything
CREATE TABLE equipment_maintenance (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  equipment_id UUID NOT NULL REFERENCES equipment(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ‚ùå WRONG - camelCase or PascalCase
CREATE TABLE EquipmentMaintenance (
  equipmentId UUID...
);
```

### Primary Keys & Timestamps
```sql
-- ‚úÖ CORRECT - UUID with gen_random_uuid()
id UUID PRIMARY KEY DEFAULT gen_random_uuid()

-- ‚úÖ CORRECT - Timestamps with timezone
created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT now()

-- ‚ùå WRONG - No default
id UUID PRIMARY KEY  -- Missing DEFAULT
```

### Foreign Keys & Constraints
```sql
-- ‚úÖ CORRECT - Explicit ON DELETE behavior
customer_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
booking_id UUID NOT NULL REFERENCES bookings(id) ON DELETE RESTRICT,

-- ‚úÖ CORRECT - CHECK constraints
status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (
  status IN ('pending', 'confirmed', 'cancelled', 'completed')
),
```

### Indexing (MANDATORY)

**Reference actual migrations**:
- Critical FK indexes: @supabase/migrations/20250122000004_add_critical_fk_indexes.sql
- More FK indexes: @supabase/migrations/20250122000006_add_more_fk_indexes.sql
- Missing indexes (RLS & availability): @supabase/migrations/20251118_add_missing_indexes.sql
- Performance optimizations: @supabase/migrations/20250121000006_performance_optimizations.sql

**Always index these**:
1. **Foreign keys** - Every FK column must have an index
2. **WHERE clause columns** - Columns used in WHERE clauses
3. **RLS policy columns** - ALL columns referenced in RLS policies
4. **Sort columns** - Columns used in ORDER BY
5. **Composite indexes** - For common query patterns
6. **Partial indexes** - For filtered queries (WHERE clause in index)
7. **GIN indexes** - For JSONB and array columns
8. **BRIN indexes** - For large tables with sequential/time series data

**Basic Index Examples**:
```sql
-- ‚úÖ Example 1: Foreign key index
CREATE INDEX CONCURRENTLY idx_bookings_customer_id ON bookings(customer_id);

-- ‚úÖ Example 2: WHERE clause index
CREATE INDEX CONCURRENTLY idx_bookings_status ON bookings(status);

-- ‚úÖ Example 3: RLS policy column index
CREATE INDEX CONCURRENTLY idx_bookings_customer_status
ON bookings(customer_id, status);

-- ‚úÖ Example 4: Sort column index
CREATE INDEX CONCURRENTLY idx_bookings_created_desc
ON bookings(created_at DESC);
```

**Advanced Index Examples from Actual Migrations**:
```sql
-- ‚úÖ Example 5: Partial index for availability queries
CREATE INDEX CONCURRENTLY idx_bookings_availability
ON bookings(equipment_id, start_date, end_date)
WHERE status NOT IN ('cancelled', 'rejected', 'completed');
```
**Index Type Reference**:
- Partial indexes: Use `WHERE` clause to index subset of rows (smaller index, faster queries)
- GIN indexes: Use `USING gin()` for JSONB, arrays, full-text search (faster containment queries)
- BRIN indexes: Use `USING brin()` for large tables with sequential data (smaller index, good for time series)
- Composite indexes: Multiple columns in single index (order matters - most selective first)

See full examples:
- Partial indexes: @supabase/migrations/20250121000006_performance_optimizations.sql:145-149
- GIN indexes: @supabase/migrations/20250121000006_performance_optimizations.sql:157-163
- BRIN indexes: @supabase/migrations/20250121000006_performance_optimizations.sql:165-167
- Composite indexes: @supabase/migrations/20250121000006_performance_optimizations.sql:151-155

```sql
-- ‚úÖ Example 6: Partial index for active bookings
CREATE INDEX CONCURRENTLY idx_bookings_active_period
ON bookings(start_date, end_date)
WHERE status IN ('confirmed', 'active');
```
See: @supabase/migrations/20250121000006_performance_optimizations.sql:146

```sql
-- ‚úÖ Example 7: GIN index for JSONB columns
CREATE INDEX CONCURRENTLY idx_equipment_specifications
ON equipment USING gin(specifications);
```
See: @supabase/migrations/20250121000006_performance_optimizations.sql:158

```sql
-- ‚úÖ Example 8: BRIN index for time series data
CREATE INDEX CONCURRENTLY idx_bookings_created_at_brin
ON bookings USING brin(created_at);
```
See: @supabase/migrations/20250121000006_performance_optimizations.sql:167

```sql
-- ‚úÖ Example 9: Composite index for complex queries
CREATE INDEX CONCURRENTLY idx_bookings_equipment_customer
ON bookings(equipment_id, customer_id, status, start_date);
```
See: @supabase/migrations/20250121000006_performance_optimizations.sql:152

### Updated_at Trigger
```sql
-- ‚úÖ CORRECT - Add to all tables
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at
BEFORE UPDATE ON bookings
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

---

## 3) Row-Level Security (RLS)

### RLS Golden Rules
1. ‚úÖ **ENABLE RLS on EVERY user-facing table**
2. ‚úÖ **Separate policies for each operation** (SELECT/INSERT/UPDATE/DELETE)
3. ‚úÖ **Use `(SELECT auth.uid())` wrapper** for better plan caching
4. ‚úÖ **Index ALL columns in policies**

### Pattern 1: Customer Ownership (Bookings, Contracts)

**Reference actual migrations**:
- Initial RLS policies: @supabase/migrations/20250121000002_rls_policies.sql:26-58
- Optimized with (SELECT auth.uid()): @supabase/migrations/20251118_fix_rls_auth_uid_wrapper.sql

```sql
-- Enable RLS
ALTER TABLE bookings ENABLE ROW LEVEL SECURITY;

-- SELECT - Users see their own OR admins see all
CREATE POLICY "bookings_select" ON bookings
FOR SELECT TO authenticated
USING (
  "customerId" = (SELECT auth.uid())  -- ‚úÖ Use (SELECT auth.uid()) wrapper for 30% faster plan caching
  OR
  EXISTS (
    SELECT 1 FROM users
    WHERE id = (SELECT auth.uid())
    AND role IN ('admin', 'super_admin')
  )
);

-- INSERT - Users create for self OR admins create for anyone
CREATE POLICY "bookings_insert" ON bookings
FOR INSERT TO authenticated
WITH CHECK (
  "customerId" = (SELECT auth.uid())
  OR
  EXISTS (
    SELECT 1 FROM users
    WHERE id = (SELECT auth.uid())
    AND role IN ('admin', 'super_admin')
  )
);

-- ‚ö†Ô∏è Index the policy columns!
CREATE INDEX CONCURRENTLY idx_bookings_customer_id
ON bookings("customerId");
```

### Pattern 2: Public Read, Admin Write (Equipment)

**Reference actual migration**: @supabase/migrations/20250121000002_rls_policies.sql:11-24

```sql
ALTER TABLE equipment ENABLE ROW LEVEL SECURITY;

-- Public can read all
CREATE POLICY "Equipment is viewable by everyone" ON equipment
FOR SELECT TO public
USING (true);

-- Only admins can modify
CREATE POLICY "Equipment is manageable by admins" ON equipment
FOR ALL TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE id = (SELECT auth.uid())  -- ‚úÖ Use wrapper for better performance
    AND role IN ('admin', 'super_admin')
  )
);
```

### Pattern 3: Admin Only (Analytics, System Config)
```sql
ALTER TABLE analytics_data ENABLE ROW LEVEL SECURITY;

CREATE POLICY "analytics_admin_only" ON analytics_data
FOR ALL TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM users
    WHERE id = (SELECT auth.uid())
    AND role IN ('admin', 'super_admin')
  )
);
```

---

## 4) Authentication & Authorization

### Client-Side (Frontend)
```typescript
// ‚úÖ CORRECT - Browser component
import { createClient } from '@/lib/supabase/client';

export default function MyComponent() {
  const supabase = createClient(); // Uses anon key

  const { data: { user } } = await supabase.auth.getUser();
  // Can read via RLS policies
}
```

### Server-Side (API Routes)
```typescript
// ‚úÖ CORRECT - Server route
import { createClient } from '@/lib/supabase/server';

export async function GET(request: NextRequest) {
  const supabase = await createClient(); // Uses cookies

  // Verify auth
  const { data: { user }, error } = await supabase.auth.getUser();
  if (error || !user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Fetch user role
  const { data: userData } = await supabase
    .from('users')
    .select('role')
    .eq('id', user.id)
    .single();

  if (userData?.role !== 'admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  // Perform privileged operation
}
```

### Environment Variables
```bash
# ‚úÖ Public (frontend) - anon key only
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGci...

# ‚úÖ Private (server) - service role key
SUPABASE_SERVICE_ROLE_KEY=eyJhbGci...

# ‚ùå NEVER expose service_role_key to client!
```

---

## 5) Type Safety with Generated Types

### Generate Types
```bash
# Generate types from Supabase schema
pnpm supabase gen types typescript --local > supabase/types.ts
```

### Use Types
```typescript
// ‚úÖ CORRECT - Typed queries
import { Database } from '@/../../supabase/types';
import { createClient } from '@/lib/supabase/client';

const supabase = createClient<Database>();

const { data } = await supabase
  .from('bookings') // ‚úÖ Autocompleted
  .select('id, bookingNumber, customer:customerId(firstName, lastName)')
  .eq('status', 'confirmed'); // ‚úÖ Type-safe
```

---

## 6) Query Optimization

### Specific Columns + Pagination
```typescript
// ‚úÖ CORRECT - Specific columns, pagination (From YOUR Codebase)
// See actual implementation: @frontend/src/app/api/bookings/route.ts:147-153
const { data, error, count } = await supabase
  .from('bookings')
  .select('id, bookingNumber, status, totalAmount', { count: 'exact' })
  .eq('status', 'confirmed')
  .gte('startDate', new Date().toISOString())
  .order('startDate', { ascending: true })
  .range(0, 19)
  .limit(20);

// ‚úÖ REAL EXAMPLE from your codebase:
// Equipment query with specific columns: @frontend/src/app/api/bookings/route.ts:147-153
const { data: equipment } = await supabase
  .from('equipment')
  .select('id, model, dailyRate, weeklyRate, monthlyRate, overageHourlyRate, dailyHourAllowance, weeklyHourAllowance')
  .eq('id', sanitized.equipmentId)
  .single();

// ‚ùå WRONG - SELECT *, no pagination (found in discount code endpoint - should be optimized)
// Reference: @frontend/src/app/api/discount-codes/validate/route.ts:61-66
const { data } = await supabase
  .from('bookings')
  .select('*'); // Returns ALL!
```

**Reference actual queries from YOUR codebase**:
- Optimized equipment query: @frontend/src/app/api/bookings/route.ts:147-153
- Availability check query: @frontend/src/app/api/bookings/route.ts:165-170
- Audit logs with specific columns: @frontend/src/app/api/admin/audit/route.ts:25-31
- Equipment summary with count: @frontend/src/app/api/admin/dashboard/overview/route.ts:176-179
- Query with joins (users relation): @frontend/src/app/api/admin/audit/export/route.ts:29-48
- Discount code query (needs optimization - uses SELECT *): @frontend/src/app/api/discount-codes/validate/route.ts:61-66

### Use Indexes
```typescript
// ‚úÖ CORRECT - Filters use indexed columns
const { data } = await supabase
  .from('bookings')
  .select('*')
  .eq('customerId', userId) // Uses idx_bookings_customer_id
  .eq('status', 'confirmed'); // Uses idx_bookings_status

// ‚ùå WRONG - Unindexed filter
const { data } = await supabase
  .from('bookings')
  .ilike('notes', '%keyword%'); // Full table scan!
```

---

## 7) Migration Safety

### Safe Migration Patterns
```sql
-- ‚úÖ CORRECT - CONCURRENTLY (no locks)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_bookings_customer_id
ON bookings(customer_id);

-- ‚úÖ CORRECT - Add column with default
ALTER TABLE bookings
ADD COLUMN IF NOT EXISTS priority VARCHAR(20) DEFAULT 'normal';

-- ‚úÖ CORRECT - Use IF NOT EXISTS/IF EXISTS
CREATE TABLE IF NOT EXISTS new_table (...);
DROP TABLE IF EXISTS old_table;

-- ‚ö†Ô∏è DANGER - Requires approval
DROP TABLE important_table; -- BACKUP FIRST!
DELETE FROM bookings; -- ALWAYS use WHERE!
```

### Testing Migrations
```bash
# ‚úÖ Test in branch first
mcp_supabase_create_branch({ name: 'test-migration' })
mcp_supabase_apply_migration({ name: '...', query: '...' })
# Test thoroughly
mcp_supabase_merge_branch({ branch_id: 'xxx' })
```

---

## 8) Storage Best Practices

### Bucket Configuration
```sql
-- ‚úÖ Private bucket with RLS
INSERT INTO storage.buckets (id, name, public)
VALUES ('contracts', 'contracts', false);

-- RLS on storage.objects
CREATE POLICY "users_upload_own_contracts" ON storage.objects
FOR INSERT TO authenticated
WITH CHECK (
  bucket_id = 'contracts'
  AND (storage.foldername(name))[1] = (SELECT auth.uid())::text
);

CREATE POLICY "users_read_own_contracts" ON storage.objects
FOR SELECT TO authenticated
USING (
  bucket_id = 'contracts'
  AND (
    (storage.foldername(name))[1] = (SELECT auth.uid())::text
    OR EXISTS (
      SELECT 1 FROM users
      WHERE id = (SELECT auth.uid())
      AND role IN ('admin', 'super_admin')
    )
  )
);
```

### Upload Operations
```typescript
// ‚úÖ CORRECT - Scoped to user folder
const uploadContract = async (file: File, bookingId: string) => {
  const supabase = createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) throw new Error('Not authenticated');

  // Scope to user folder
  const filePath = `${user.id}/${bookingId}/${file.name}`;

  const { data, error } = await supabase.storage
    .from('contracts')
    .upload(filePath, file, {
      cacheControl: '3600',
      upsert: false
    });

  if (error) throw error;

  // Generate signed URL
  const { data: signedUrl } = await supabase.storage
    .from('contracts')
    .createSignedUrl(filePath, 3600);

  return signedUrl;
};
```

---

## 9) Monitoring & Debugging

### Check Advisors Regularly
```typescript
// ‚úÖ Security issues
const securityAdvisors = await mcp_supabase_get_advisors({ type: 'security' });

// ‚úÖ Performance issues
const perfAdvisors = await mcp_supabase_get_advisors({ type: 'performance' });
```

### Check Logs for Errors
```typescript
// ‚úÖ API logs
const logs = await mcp_supabase_get_logs({ service: 'api' });

// ‚úÖ Auth logs
const authLogs = await mcp_supabase_get_logs({ service: 'auth' });
```

---

## 10) Common Mistakes to Avoid

### Database
```sql
-- ‚ùå WRONG - No indexes on foreign keys
CREATE TABLE bookings (
  customer_id UUID REFERENCES users(id) -- Missing index!
);

-- ‚ùå WRONG - Using auth.uid() directly
USING (auth.uid() = customer_id) -- Poor caching

-- ‚ùå WRONG - No RLS
CREATE TABLE sensitive_data (...); -- Must enable RLS!
```

### Frontend
```typescript
// ‚ùå WRONG - Service role in client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY // NEVER!
);

// ‚ùå WRONG - No validation
await supabase.from('bookings').insert(request.body); // Unsafe!

// ‚ùå WRONG - SELECT * without pagination
const { data } = await supabase.from('bookings').select('*');
```

---

## ‚úÖ Checklist for Every Database Change

Schema Changes:
- [ ] Migration via `mcp_supabase_apply_migration`
- [ ] Uses snake_case naming
- [ ] Has NOT NULL constraints
- [ ] Explicit ON DELETE behavior
- [ ] Indexes for foreign keys
- [ ] Updated_at trigger
- [ ] Tested in branch first

RLS Policies:
- [ ] RLS enabled on table
- [ ] Policy for each operation
- [ ] Uses `(SELECT auth.uid())` wrapper
- [ ] Policy columns indexed
- [ ] Tested with different roles

API Routes:
- [ ] Uses `@/lib/supabase/server`
- [ ] Verifies authentication
- [ ] Validates inputs (Zod + sanitization)
- [ ] Rate limiting applied
- [ ] Structured logging
- [ ] Error handling

---

**Remember**: üéØ **Supabase MCP tools ONLY** | üîí **RLS is MANDATORY** | ‚ö° **Index ALL foreign keys** | üõ°Ô∏è **Validate ALL inputs** | üìä **Monitor with advisors**
