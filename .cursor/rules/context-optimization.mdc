---
description: "Intelligent context window management for long sessions - prioritization, pruning, and refresh strategies"
alwaysApply: true
---

# Context Optimization & Management

## ðŸŽ¯ Purpose
Intelligently manage context window to maintain performance in long sessions, prioritize important information, and prevent context degradation.

---

## Context Prioritization Strategy

When context window fills (>80%), I will prioritize information:

### Tier 1: Keep (High Priority - Always Retain)
- **Active file being edited** - Current focus
- **Related component/API files** - Directly related to current work
- **Core patterns** - API route pattern, RLS pattern, Coding Savant patterns
- **Current task context** - What we're working on right now
- **Critical reference docs** - RULE_SYSTEM_MAP, AI_CODING_REFERENCE, CODING_SAVANT_CHEAT_SHEET

### Tier 2: Summarize (Medium Priority - Condense)
- **Previous implementations** - Summarize key decisions
- **Related database schema** - Keep structure, summarize details
- **Test files** - Keep test patterns, summarize test cases
- **Similar components** - Keep patterns, summarize differences

### Tier 3: Drop (Low Priority - Remove)
- **Historical conversation** - Summarize key points, drop details
- **Completed tasks** - Summarize outcomes, drop implementation details
- **Audit reports** - Not needed for coding
- **Old migration files** - Only keep recent migrations
- **Large documentation** - Reference docs indexed, don't need full content

---

## Context Refresh Strategy

### Refresh Triggers

**Every 50K tokens** (or when context >80% full):
1. **Summarize key decisions** made in session
2. **List active TODOs** and current tasks
3. **Note important constraints** and requirements
4. **Refresh with current file state** (re-read active files)
5. **Drop old file versions** (keep only latest)

### Refresh Process

```
Context >80% Full
    â†“
Summarize Session So Far
    â†“
Extract Key Decisions
    â†“
List Active TODOs
    â†“
Refresh Active Files
    â†“
Drop Low-Priority Content
    â†“
Continue with Optimized Context
```

---

## Proactive Context Management

### Monitoring

I will monitor context usage and notify when:
- **Context >80% full** â†’ "Context window 80% full, optimizing..."
- **About to drop important info** â†’ "Dropping low-priority content, keeping critical files"
- **Need to refresh** â†’ "Refreshing context window, summarizing session..."

### Optimization Actions

**When Context >80%**:
1. **Summarize completed tasks** â†’ "Completed: Created BookingCard component, added cancel API"
2. **Condense file history** â†’ Keep latest version, summarize changes
3. **Remove redundant info** â†’ Drop duplicate patterns, keep single source
4. **Prioritize active work** â†’ Keep files related to current task

---

## Context Prioritization Matrix

### File Priority Levels

| Priority | File Types | Action |
|----------|------------|--------|
| **Critical** | Active file, core patterns, critical docs | Always keep |
| **High** | Related files, current task context | Keep, summarize if needed |
| **Medium** | Previous implementations, similar code | Summarize key points |
| **Low** | Historical conversation, completed tasks | Drop after summarizing |

### Pattern Priority

| Pattern Type | Priority | Action |
|--------------|----------|--------|
| **Coding Savant patterns** | Critical | Always keep |
| **API route pattern** | Critical | Always keep |
| **RLS policy pattern** | Critical | Always keep |
| **Component patterns** | High | Keep, summarize if needed |
| **Test patterns** | Medium | Summarize, keep key examples |

---

## Context Pruning Rules

### What to Prune

**Always Prune**:
- Old file versions (keep only latest)
- Duplicate information (keep single source)
- Completed task details (keep summary)
- Historical conversation (keep key decisions)

**Conditionally Prune**:
- Large documentation (reference indexed docs instead)
- Test fixtures (keep patterns, drop data)
- Migration history (keep recent, summarize old)

**Never Prune**:
- Active file being edited
- Core patterns (Coding Savant, API route, RLS)
- Critical reference docs
- Current task context

---

## Smart Context Loading

### Load Order

1. **Critical files first** (from `.cursor/indexing.json`)
   - RULE_SYSTEM_MAP.md
   - AI_CODING_REFERENCE.md
   - CODING_SAVANT_CHEAT_SHEET.md
   - supabase/types.ts

2. **Active work files**
   - File being edited
   - Related components/APIs
   - Current task context

3. **Supporting files**
   - Similar patterns
   - Reference implementations
   - Related utilities

### Load Strategy

```
Session Start
    â†“
Load Critical Files (indexing.json priorities)
    â†“
Load Active Work Files
    â†“
Load Supporting Files (as needed)
    â†“
Monitor Context Usage
    â†“
Optimize When >80% Full
```

---

## Context Window Budget

### Allocation Strategy

**150K token budget**:
- **Always-Applied Rules**: ~25K (17%)
- **Critical Reference Docs**: ~15K (10%)
- **Active Work Files**: ~40K (27%)
- **Supporting Context**: ~30K (20%)
- **Buffer for Growth**: ~40K (27%)

**When >120K tokens (80%)**:
- Summarize supporting context
- Drop low-priority content
- Refresh active files
- Maintain buffer

---

## Context Refresh Examples

### Example 1: Long Session

```
Session Start (0K tokens)
    â†“
Work on Feature A (40K tokens)
    â†“
Work on Feature B (80K tokens)
    â†“
Context >80% (120K tokens)
    â†“
Refresh:
  - Summarize Feature A: "Created BookingCard component with cancel action"
  - Keep Feature B context active
  - Drop Feature A implementation details
    â†“
Continue with Feature B (80K tokens available)
```

### Example 2: Multiple Files

```
Editing 5 related files (100K tokens)
    â†“
Context >80% (120K tokens)
    â†“
Refresh:
  - Keep active file (highest priority)
  - Summarize other 4 files: "Related components use similar patterns"
  - Keep core patterns
    â†“
Continue with active file (100K tokens available)
```

---

## Notification Protocol

### When Optimizing Context

I will notify user:
```
ðŸ”„ Context Optimization

Context window: 85% full (127K/150K tokens)
Optimizing context:
  âœ“ Summarized completed tasks
  âœ“ Refreshed active files
  âœ“ Dropped low-priority content
  â†’ Context now: 75% full (112K/150K tokens)
  â†’ Ready to continue
```

### When Refresh Needed

I will notify user:
```
ðŸ”„ Context Refresh

Refreshing context window:
  â†’ Summarizing session progress
  â†’ Extracting key decisions
  â†’ Refreshing active files
  â†’ Context optimized for continued work
```

---

## Performance Targets

### Context Management Goals

- **Context Load Time**: <1s for critical files
- **Refresh Time**: <2s for context optimization
- **Context Efficiency**: >80% of tokens used for active work
- **Refresh Frequency**: Every 50K tokens or when >80% full

---

## âœ… Success Criteria

Context is optimized when:
- âœ… Critical files always available
- âœ… Active work has sufficient context
- âœ… Context window stays <90% full
- âœ… No important information lost
- âœ… Performance maintained in long sessions

---

## ðŸŽ¯ Usage

### For AI Model (Automatic)

I will automatically:
1. Monitor context usage
2. Prioritize important information
3. Summarize when needed
4. Refresh proactively
5. Notify when optimizing

### For Developers

You'll see notifications like:
```
ðŸ”„ Context Optimization: Summarized completed tasks, refreshed active files
```

This means I'm managing context to maintain performance.

---

**Status**: âœ… Active Context Management System
**Refresh Strategy**: Every 50K tokens or >80% full
**Priority System**: 3-tier (Critical/High/Medium/Low)
